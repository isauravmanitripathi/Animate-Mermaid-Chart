# Project Tree
auto-mermaid-chart/
    .DS_Store
    .gitignore
    __init__.py
    distributed_algorithm.mp4
    files.py
    layout.json
    LICENSE
    main.py
    parsed_graph.json
    README.md
    requirements.txt
    setup.py
    test-1.mp4
    test-2.mp4
    animator/
        __init__.py
        animator.py
        __pycache__/
            __init__.cpython-310.pyc
            animator.cpython-310.pyc
    examples/
        __init__.py
        examples.py
        __pycache__/
            __init__.cpython-310.pyc
            examples.cpython-310.pyc
    layout/
        __init__.py
        layout.py
        __pycache__/
            __init__.cpython-310.pyc
            layout.cpython-310.pyc
    parser/
        __init__.py
        parser.py
        __pycache__/
            __init__.cpython-310.pyc
            parser.cpython-310.pyc

# Combined Python Files
# File: __init__.py
# __init__.py (root level)

import logging
from parser.parser import MermaidParser
from layout.layout import SugiyamaLayoutGenerator
from animator.animator import MermaidAnimator, AnimationConfig, Node, Edge  # Added Node, Edge
from examples.examples import MermaidExamples

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def convert_layout_to_animator(layout) -> tuple[dict[str, Node], list[Edge]]:
    """Convert layout to animator nodes and edges"""
    # Convert all nodes, including dummy nodes
    nodes = {
        node_id: Node(
            id=node_id,
            label=node.label if not getattr(node, 'dummy', False) else "",
            type=node.type,
            position=(node.x, node.y),
            layer=node.rank  # Use rank as layer
        )
        for node_id, node in layout.nodes.items()
    }
    
    # Convert edges with their calculated points
    edges = []
    for edge in layout.edges:
        if edge.points and len(edge.points) >= 2:
            edges.append(Edge(
                start_node=edge.from_id,
                end_node=edge.to_id,
                label=edge.label,
                start_pos=edge.points[0],
                end_pos=edge.points[-1]
            ))
    
    return nodes, edges

def create_animated_diagram(mermaid_code: str, output_file: str = "animation.mp4"):
    """Create an animated diagram from Mermaid code"""
    logger.info("Step 1: Parsing Mermaid code")
    parser = MermaidParser()
    parsed_graph = parser.parse(mermaid_code)
    parser.save_json("parsed_graph.json")
    
    logger.info("Step 2: Generating layout")
    layout_generator = SugiyamaLayoutGenerator(
        width=1920,
        height=1080,
        node_spacing=150,
        rank_spacing=250
    )
    layout = layout_generator.generate_layout(parsed_graph)
    layout_generator.save_json(layout, "layout.json")
    
    logger.info("Step 3: Creating animation")
    config = AnimationConfig(
        width=1920,
        height=1080,
        fps=30,
        node_spacing=150,
        layer_spacing=250,
        animation_duration=1.5,
        background_color="white",
        node_color="white",
        edge_color="black",
        text_color="black"
    )
    
    animator = MermaidAnimator(config)
    nodes, edges = convert_layout_to_animator(layout)
    animator.nodes = nodes
    animator.edges = edges
    
    animator.create_animation(output_file)
    logger.info(f"Animation saved to {output_file}")

if __name__ == "__main__":
    # 1. Software Architecture
    # mermaid_code = MermaidExamples.get_software_architecture()
    # create_animated_diagram(mermaid_code, "software_architecture.mp4")
    
    # 2. Business Process
    # mermaid_code = MermaidExamples.get_business_process()
    # create_animated_diagram(mermaid_code, "business_process.mp4")
    
    # 3. System State
    # mermaid_code = MermaidExamples.get_system_state()
    # create_animated_diagram(mermaid_code, "system_state.mp4")
    
    # 4. Indian Economy
    mermaid_code = MermaidExamples.get_indian_economy()
    create_animated_diagram(mermaid_code, "indian_economy.mp4")

--------------------------------------------------------------------------------

# File: files.py
import os

# Configuration: Add folder and file names to ignore
IGNORED_FOLDERS = {".venv", ".", ".git"}
IGNORED_FILES = {"ignore_this.py"}  # Example ignored files

# Output file name
OUTPUT_FILE = "combined_python_files.txt"

def build_project_tree(base_path):
    """Build a tree of the project structure."""
    tree_lines = []
    for root, dirs, files in os.walk(base_path):
        # Ignore specified folders
        dirs[:] = [d for d in dirs if d not in IGNORED_FOLDERS]

        # Indent tree structure
        level = root.replace(base_path, "").count(os.sep)
        indent = "    " * level
        tree_lines.append(f"{indent}{os.path.basename(root)}/")

        # Add files to the tree
        for file in files:
            tree_lines.append(f"{indent}    {file}")

    return "\n".join(tree_lines)

def collect_python_files(base_path):
    """Collect Python files from the project directory."""
    python_files = []
    for root, dirs, files in os.walk(base_path):
        # Ignore specified folders
        dirs[:] = [d for d in dirs if d not in IGNORED_FOLDERS]
        
        for file in files:
            if file.endswith(".py") and file not in IGNORED_FILES:
                python_files.append(os.path.join(root, file))

    return python_files

def combine_python_files(file_paths):
    """Combine the content of all Python files into a single string."""
    combined_content = []
    for file_path in file_paths:
        combined_content.append(f"# File: {os.path.relpath(file_path)}")
        with open(file_path, "r", encoding="utf-8") as f:
            combined_content.append(f.read())
        combined_content.append("\n" + "-" * 80 + "\n")  # Separator

    return "\n".join(combined_content)

def main():
    base_path = os.path.dirname(os.path.abspath(__file__))

    # Build project tree
    project_tree = build_project_tree(base_path)

    # Collect Python files
    python_files = collect_python_files(base_path)

    # Combine Python files' content
    combined_content = combine_python_files(python_files)

    # Write output file
    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        f.write("# Project Tree\n")
        f.write(project_tree)
        f.write("\n\n" + "# Combined Python Files\n")
        f.write(combined_content)

    print(f"Combined Python files saved to {OUTPUT_FILE}")

if __name__ == "__main__":
    main()


--------------------------------------------------------------------------------

# File: main.py
# main.py

from animator.animator import MermaidAnimator, AnimationConfig, Node, Edge
from examples.examples import MermaidExamples
from parser.parser import MermaidParser
from layout.layout import SugiyamaLayoutGenerator
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def convert_layout_to_animator(layout) -> tuple[dict[str, Node], list[Edge]]:
    """Convert layout to animator nodes and edges"""
    # Convert all nodes, including dummy nodes
    nodes = {
        node_id: Node(
            id=node_id,
            label=node.label if not getattr(node, 'dummy', False) else "",
            type=node.type,
            position=(node.x, node.y),
            layer=node.rank  # Use rank as layer
        )
        for node_id, node in layout.nodes.items()
    }
    
    # Convert edges with their calculated points
    edges = []
    for edge in layout.edges:
        if edge.points and len(edge.points) >= 2:
            edges.append(Edge(
                start_node=edge.from_id,
                end_node=edge.to_id,
                label=edge.label,
                start_pos=edge.points[0],
                end_pos=edge.points[-1]
            ))
    
    return nodes, edges

def create_animated_diagram(mermaid_code: str, output_file: str = "animation.mp4"):
    """Create an animated diagram from Mermaid code"""
    logger.info("Step 1: Parsing Mermaid code")
    parser = MermaidParser()
    parsed_graph = parser.parse(mermaid_code)
    parser.save_json("parsed_graph.json")
    
    logger.info("Step 2: Generating layout")
    layout_generator = SugiyamaLayoutGenerator(
        width=1920,
        height=1080,
        node_spacing=150,
        rank_spacing=250
    )
    layout = layout_generator.generate_layout(parsed_graph)
    layout_generator.save_json(layout, "layout.json")
    
    logger.info("Step 3: Creating animation")
    config = AnimationConfig(
        width=1920,
        height=1080,
        fps=30,
        node_spacing=150,
        layer_spacing=250,
        node_animation_duration=0.5,  # Duration for each node animation
        edge_animation_duration=0.5,  # Duration for each edge animation
        node_delay=0.2,             # Delay before next node starts
        edge_delay=0.2,             # Delay before connected edge starts
        background_color="white",
        node_color="white",
        edge_color="black",
        text_color="black"
    )
    
    animator = MermaidAnimator(config)
    nodes, edges = convert_layout_to_animator(layout)
    animator.nodes = nodes
    animator.edges = edges
    
    animator.create_animation(output_file)
    logger.info(f"Animation saved to {output_file}")

if __name__ == "__main__":
    mermaid_code = MermaidExamples.get_economy_lr()  # Changed this line
    create_animated_diagram(mermaid_code, "test-2.mp4")

--------------------------------------------------------------------------------

# File: setup.py
# setup.py

from setuptools import setup, find_packages

setup(
    name="auto-mermaid-chart",
    version="0.1",
    packages=find_packages(),
    install_requires=[
        'Pillow>=10.1.0',
        'dataclasses>=0.6',
        'typing-extensions>=4.8.0'
    ],
)

--------------------------------------------------------------------------------

# File: animator/__init__.py


--------------------------------------------------------------------------------

# File: animator/animator.py
"""
MermaidAnimator: A library for creating animated diagrams from Mermaid syntax with sequential animation
"""

from parser.parser import MermaidParser
from layout.layout import SugiyamaLayoutGenerator
from PIL import Image, ImageDraw, ImageFont
import os
import shutil
from math import sin, cos, atan2, pi, tan
import subprocess
from collections import defaultdict
from typing import Dict, List, Tuple, Optional, Union, Set
from dataclasses import dataclass
import logging
import json

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class Node:
    """Represents a node in the diagram"""
    id: str
    label: str
    type: str  # 'default', 'square', 'round', 'diamond'
    position: Optional[Tuple[float, float]] = None
    layer: int = 0
    sequence_number: int = 0  # Added for sequential animation
    animation_start_time: float = 0.0  # When this node starts animating

@dataclass
class Edge:
    """Represents an edge between nodes"""
    start_node: str
    end_node: str
    label: str
    start_pos: Optional[Tuple[float, float]] = None
    end_pos: Optional[Tuple[float, float]] = None
    sequence_number: int = 0  # Added for sequential animation
    animation_start_time: float = 0.0  # When this edge starts animating

@dataclass
class AnimationConfig:
    """Configuration for animation settings"""
    width: int = 1920
    height: int = 1080
    fps: int = 30
    node_spacing: int = 200
    layer_spacing: int = 300
    node_animation_duration: float = 0.5  # Duration for each node animation
    edge_animation_duration: float = 0.5  # Duration for each edge animation
    node_delay: float = 0.2  # Delay before next node starts
    edge_delay: float = 0.2  # Delay before connected edge starts
    background_color: str = "white"
    node_color: str = "white"
    edge_color: str = "black"
    text_color: str = "black"
    line_width: int = 3
    font_size: int = 20

class MermaidAnimator:
    """Main class for parsing Mermaid syntax and generating sequential animations"""
    
    def __init__(self, config: Optional[AnimationConfig] = None):
        self.config = config or AnimationConfig()
        self.nodes: Dict[str, Node] = {}
        self.edges: List[Edge] = []
        self._sequence_count = 0  # Track animation sequence
        self._total_duration = 0.0  # Total animation duration
        self._setup_font()
        
    def _setup_font(self):
        """Initialize font for text rendering"""
        try:
            self.font = ImageFont.truetype("Arial.ttf", self.config.font_size)
        except OSError:
            logger.warning("Arial font not found, using default font")
            self.font = ImageFont.load_default()

    def _calculate_animation_sequence(self):
        """Calculate the sequence of node and edge animations"""
        # Reset sequence tracking
        self._sequence_count = 0
        current_time = 0.0
        processed_nodes = set()
        
        # Find root nodes (nodes with no incoming edges)
        incoming_edges = {edge.end_node for edge in self.edges}
        root_nodes = [nid for nid in self.nodes if nid not in incoming_edges]
        if not root_nodes:
            root_nodes = [next(iter(self.nodes.keys()))]
        
        # Process nodes in sequence
        nodes_to_process = root_nodes.copy()
        while nodes_to_process:
            current_node_id = nodes_to_process.pop(0)
            if current_node_id in processed_nodes:
                continue
                
            # Set node sequence and timing
            node = self.nodes[current_node_id]
            node.sequence_number = self._sequence_count
            node.animation_start_time = current_time
            self._sequence_count += 1
            processed_nodes.add(current_node_id)
            
            # Find connected edges and nodes
            connected_edges = [edge for edge in self.edges if edge.start_node == current_node_id]
            for edge in connected_edges:
                # Set edge timing slightly after node appears
                edge.sequence_number = self._sequence_count
                edge.animation_start_time = current_time + self.config.node_animation_duration + self.config.edge_delay
                self._sequence_count += 1
                
                # Queue connected node if not processed
                if edge.end_node not in processed_nodes:
                    nodes_to_process.append(edge.end_node)
            
            # Update timing for next node
            current_time += (self.config.node_animation_duration + self.config.node_delay)
        
        # Store total animation duration
        self._total_duration = current_time + self.config.node_animation_duration

    def _calculate_element_progress(self, time: float, start_time: float, duration: float) -> float:
        """Calculate animation progress for an element"""
        if time < start_time:
            return 0.0
        if time >= start_time + duration:
            return 1.0
        return (time - start_time) / duration

    def _create_frame(self, time: float, frame_number: int, temp_dir: str) -> str:
        """Create a single frame of the animation with sequential node and edge appearance"""
        img = Image.new('RGB', (self.config.width, self.config.height), 
                       self.config.background_color)
        draw = ImageDraw.Draw(img)
        
        # Process edges first (they'll be drawn behind nodes)
        for edge in self.edges:
            progress = self._calculate_element_progress(
                time, 
                edge.animation_start_time,
                self.config.edge_animation_duration
            )
            if progress > 0:
                self._draw_edge(draw, edge, progress)
        
        # Process nodes
        for node in self.nodes.values():
            progress = self._calculate_element_progress(
                time,
                node.animation_start_time,
                self.config.node_animation_duration
            )
            if progress > 0:
                self._draw_node(draw, node, progress)
        
        frame_path = os.path.join(temp_dir, f"frame_{frame_number:04d}.png")
        img.save(frame_path, quality=95, optimize=True)
        return frame_path

    def _draw_node(self, draw: ImageDraw, node: Node, progress: float) -> None:
        """Draw a node with animation progress"""
        if not node.position:
            return
            
        x, y = node.position
        
        # Calculate node size based on text
        text_bbox = draw.textbbox((0, 0), node.label, font=self.font)
        text_width = text_bbox[2] - text_bbox[0]
        text_height = text_bbox[3] - text_bbox[1]
        
        # Add padding around text
        PADDING = 20
        w = max(80, text_width + PADDING * 2) * progress
        h = max(80, text_height + PADDING * 2) * progress
        
        # Draw node based on type with animation
        if node.type == 'diamond':
            points = [
                (x, y - h/2),
                (x + w/2, y),
                (x, y + h/2),
                (x - w/2, y)
            ]
            draw.polygon(points, fill=self.config.node_color)
            for i in range(len(points)):
                start = points[i]
                end = points[(i + 1) % len(points)]
                draw.line([start, end], fill=self.config.edge_color, 
                         width=self.config.line_width)
                         
        elif node.type == 'round':
            left = x - w/2
            top = y - h/2
            right = x + w/2
            bottom = y + h/2
            draw.ellipse([left, top, right, bottom], 
                        outline=self.config.edge_color,
                        fill=self.config.node_color, 
                        width=self.config.line_width)
                        
        else:  # square or default
            left = x - w/2
            top = y - h/2
            right = x + w/2
            bottom = y + h/2
            draw.rectangle([left, top, right, bottom], 
                         outline=self.config.edge_color,
                         fill=self.config.node_color, 
                         width=self.config.line_width)
        
        # Draw text with fade-in effect
        if progress > 0.5:
            text_progress = min(1, (progress - 0.5) * 2)
            text_x = x - text_width/2
            text_y = y - text_height/2
            
            # Handle color conversion and alpha
            if isinstance(self.config.text_color, str):
                if self.config.text_color == "black":
                    text_color = (0, 0, 0, int(255 * text_progress))
                else:
                    text_color = (0, 0, 0, int(255 * text_progress))
            else:
                text_color = (*self.config.text_color[:3], int(255 * text_progress))
                
            draw.text((text_x, text_y), node.label,
                     fill=text_color,
                     font=self.font)

    def _draw_edge(self, draw: ImageDraw, edge: Edge, progress: float) -> None:
        """Draw an edge with animation progress"""
        if not edge.start_pos or not edge.end_pos:
            return
            
        start = self._calculate_intersection(edge.start_pos, edge.end_pos, (80, 80), True)
        end = self._calculate_intersection(edge.start_pos, edge.end_pos, (80, 80), False)
        
        # Animate line drawing
        current_x = start[0] + (end[0] - start[0]) * progress
        current_y = start[1] + (end[1] - start[1]) * progress
        
        # Draw the line
        draw.line([start[0], start[1], current_x, current_y], 
                 fill=self.config.edge_color, 
                 width=self.config.line_width)
        
        # Draw arrow head when edge is mostly drawn
        if progress > 0.8:
            arrow_progress = min(1, (progress - 0.8) * 5)
            self._draw_arrow_head(draw, (current_x, current_y), end, arrow_progress)
        
        # Draw edge label with fade in
        if edge.label and progress > 0.5:
            label_progress = min(1, (progress - 0.5) * 2)
            self._draw_edge_label(draw, edge.label, start, (current_x, current_y), label_progress)

    def _calculate_intersection(self, start_pos: Tuple[float, float], 
                              end_pos: Tuple[float, float],
                              box_size: Tuple[float, float], 
                              is_start: bool) -> Tuple[float, float]:
        """Calculate where line intersects with node boundary"""
        x1, y1 = start_pos
        x2, y2 = end_pos
        w, h = box_size
        
        angle = atan2(y2 - y1, x2 - x1)
        center = start_pos if is_start else end_pos
        
        if abs(cos(angle)) > abs(sin(angle)):
            x_offset = (w/2) * (1 if is_start else -1)
            y_offset = x_offset * tan(angle)
        else:
            y_offset = (h/2) * (1 if is_start else -1)
            x_offset = y_offset / tan(angle)
            
        return (center[0] + x_offset, center[1] + y_offset)

    def _draw_arrow_head(self, draw: ImageDraw, current: Tuple[float, float], 
                        end: Tuple[float, float], progress: float) -> None:
        """Draw arrow head with animation progress"""
        arrow_size = 15 * progress
        angle = atan2(end[1] - current[1], end[0] - current[0])
        
        ax1 = current[0] - arrow_size * cos(angle - pi/6)
        ay1 = current[1] - arrow_size * sin(angle - pi/6)
        ax2 = current[0] - arrow_size * cos(angle + pi/6)
        ay2 = current[1] - arrow_size * sin(angle + pi/6)
        
        draw.polygon([(current[0], current[1]), (ax1, ay1), (ax2, ay2)], 
                    fill=self.config.edge_color)

    def _draw_edge_label(self, draw: ImageDraw, label: str, start: Tuple[float, float], 
                        current: Tuple[float, float], progress: float) -> None:
        """Draw edge label with fade-in effect"""
        mid_x = (start[0] + current[0]) / 2
        mid_y = (start[1] + current[1]) / 2 - 15
        
        text_bbox = draw.textbbox((0, 0), label, font=self.font)
        text_width = text_bbox[2] - text_bbox[0]
        text_height = text_bbox[3] - text_bbox[1]
        
        label_x = mid_x - text_width/2
        label_y = mid_y - text_height/2
        
        # Draw background with fade-in
        padding = 5
        draw.rectangle([
            label_x - padding,
            label_y - padding,
            label_x + text_width + padding,
            label_y + text_height + padding
        ], fill=self.config.background_color)
        
        # Draw text with fade-in
        if isinstance(self.config.text_color, str):
            if self.config.text_color == "black":
                text_color = (0, 0, 0, int(255 * progress))
            else:
                text_color = (0, 0, 0, int(255 * progress))
        else:
            text_color = (*self.config.text_color[:3], int(255 * progress))
            
        draw.text((label_x, label_y), label, 
                 fill=text_color,
                 font=self.font)

    def create_animation(self, output_filename: str = "animation.mp4") -> None:
        """Create the final animation video with sequential appearance"""
        temp_dir = "output_frames"
        
        # Calculate animation sequence and timing
        self._calculate_animation_sequence()
        
        # Setup temporary directory for frames
        if os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)
        os.makedirs(temp_dir)
        
        try:
            # Calculate total frames needed
            total_frames = int(self._total_duration * self.config.fps)
            logger.info(f"Generating {total_frames} frames for {self._total_duration:.2f} seconds of animation...")
            
            for frame in range(total_frames):
                t = frame / self.config.fps
                self._create_frame(t, frame, temp_dir)
                
                if frame % 10 == 0:  # Progress update every 10 frames
                    logger.info(f"Progress: {frame}/{total_frames} frames ({(frame/total_frames*100):.1f}%)")
            
            # Combine frames into video using ffmpeg
            logger.info("Creating video with ffmpeg...")
            ffmpeg_cmd = [
                'ffmpeg',
                '-y',  # Overwrite output file if it exists
                '-framerate', str(self.config.fps),
                '-i', os.path.join(temp_dir, 'frame_%04d.png'),
                '-c:v', 'libx264',
                '-preset', 'slow',
                '-crf', '18',
                '-pix_fmt', 'yuv420p',
                output_filename
            ]
            
            try:
                subprocess.run(ffmpeg_cmd, check=True, capture_output=True)
                logger.info(f"Animation saved to {output_filename}")
            except subprocess.CalledProcessError as e:
                logger.error(f"FFmpeg error: {e.stderr.decode()}")
                raise RuntimeError("Failed to create video with FFmpeg")
                
        finally:
            # Cleanup temporary files
            if os.path.exists(temp_dir):
                shutil.rmtree(temp_dir)

    def save_layout_json(self, filename: str) -> None:
        """Save the current layout to a JSON file"""
        layout_data = {
            'nodes': {
                node_id: {
                    'label': node.label,
                    'type': node.type,
                    'position': node.position,
                    'layer': node.layer,
                    'sequence_number': node.sequence_number,
                    'animation_start_time': node.animation_start_time
                } for node_id, node in self.nodes.items()
            },
            'edges': [
                {
                    'start_node': edge.start_node,
                    'end_node': edge.end_node,
                    'label': edge.label,
                    'start_pos': edge.start_pos,
                    'end_pos': edge.end_pos,
                    'sequence_number': edge.sequence_number,
                    'animation_start_time': edge.animation_start_time
                } for edge in self.edges
            ],
            'config': {
                'width': self.config.width,
                'height': self.config.height,
                'fps': self.config.fps,
                'node_spacing': self.config.node_spacing,
                'layer_spacing': self.config.layer_spacing,
                'node_animation_duration': self.config.node_animation_duration,
                'edge_animation_duration': self.config.edge_animation_duration,
                'node_delay': self.config.node_delay,
                'edge_delay': self.config.edge_delay
            }
        }
        
        with open(filename, 'w') as f:
            json.dump(layout_data, f, indent=2)
            
    @classmethod
    def load_layout_json(cls, filename: str) -> 'MermaidAnimator':
        """Create a new MermaidAnimator instance from a saved layout"""
        with open(filename, 'r') as f:
            layout_data = json.load(f)
            
        config = AnimationConfig(**layout_data['config'])
        animator = cls(config)
        
        # Reconstruct nodes
        for node_id, node_data in layout_data['nodes'].items():
            animator.nodes[node_id] = Node(
                id=node_id,
                label=node_data['label'],
                type=node_data['type'],
                position=tuple(node_data['position']) if node_data['position'] else None,
                layer=node_data['layer'],
                sequence_number=node_data['sequence_number'],
                animation_start_time=node_data['animation_start_time']
            )
            
        # Reconstruct edges
        for edge_data in layout_data['edges']:
            animator.edges.append(Edge(
                start_node=edge_data['start_node'],
                end_node=edge_data['end_node'],
                label=edge_data['label'],
                start_pos=tuple(edge_data['start_pos']) if edge_data['start_pos'] else None,
                end_pos=tuple(edge_data['end_pos']) if edge_data['end_pos'] else None,
                sequence_number=edge_data['sequence_number'],
                animation_start_time=edge_data['animation_start_time']
            ))
            
        return animator


def create_example_animation():
    """Create an example animation to demonstrate usage"""
    # Create custom configuration
    config = AnimationConfig(
        width=1920,
        height=1080,
        fps=30,
        node_spacing=200,
        layer_spacing=300,
        node_animation_duration=0.5,
        edge_animation_duration=0.5,
        node_delay=0.2,
        edge_delay=0.2,
        background_color="white",
        node_color="white",
        edge_color="black",
        text_color="black"
    )
    
    # Initialize animator with config
    animator = MermaidAnimator(config)
    
    # Example Mermaid code
    mermaid_code = """
    graph TD
        A[Start] --> B{Is it?}
        B -->|Yes| C[OK]
        B -->|No| D[End]
        C --> D
        C --> E[Rethink]
        E --> B
    """
    
    # Parse and create animation
    parser = MermaidParser()
    layout_generator = SugiyamaLayoutGenerator(
        width=config.width,
        height=config.height,
        node_spacing=config.node_spacing,
        rank_spacing=config.layer_spacing
    )
    
    parsed_graph = parser.parse(mermaid_code)
    layout = layout_generator.generate_layout(parsed_graph)
    
    # Convert layout to animator format
    for node_id, layout_node in layout.nodes.items():
        animator.nodes[node_id] = Node(
            id=node_id,
            label=layout_node.label,
            type=layout_node.type,
            position=(layout_node.x, layout_node.y),
            layer=layout_node.rank
        )
    
    for edge in layout.edges:
        if edge.points and len(edge.points) >= 2:
            animator.edges.append(Edge(
                start_node=edge.from_id,
                end_node=edge.to_id,
                label=edge.label,
                start_pos=edge.points[0],
                end_pos=edge.points[-1]
            ))
    
    # Create the animation
    animator.create_animation("example_animation.mp4")


if __name__ == "__main__":
    create_example_animation()

--------------------------------------------------------------------------------

# File: examples/__init__.py


--------------------------------------------------------------------------------

# File: examples/examples.py
class MermaidExamples:
    @staticmethod
    def get_economy_lr():
        return """
        graph LR
            India[Indian Economy] --> Pre91[Pre-1991]
            India --> Post91[Post-1991]
            
            Pre91 --> Soviet[Soviet Model]
            Soviet --> License[License Raj]
            Soviet --> StateControl[State Control]
            
            Post91 --> Crisis[BOP Crisis]
            Post91 --> Liberal[Liberalization]
            Liberal --> Mixed[Mixed Economy]
            
            Mixed --> Public[Public Sector]
            Mixed --> Private[Private Sector]
            
            Public --> Core[Strategic Sectors]
            Core --> Rail[Railways]
            Core --> Highway[Highways]
            Core --> Bank[Banking]
            Core --> Defense[Defense]
            Core --> Digital[Digital Infrastructure]
            Core --> Energy[Energy]
        """
    
    @staticmethod
    def get_economy_td():
        return """
        graph TD
            Economy[Indian Economy] --> Historical[Historical Evolution]
            Economy --> Current[Current Structure]
            
            Historical --> Pre[Pre-1991 Era]
            Historical --> Post[Post-1991 Era]
            
            Pre --> Soviet[Soviet Model]
            Soviet --> Protect[Protectionist Policies]
            Soviet --> State[State Intervention]
            Soviet --> License[License Raj]
            
            Post --> Crisis[1991 Crisis]
            Post --> Liberal[Liberalization]
            Post --> Mixed[Mixed Economy]
            
            Current --> PSU[Public Sector]
            Current --> PVT[Private Sector]
            
            PSU --> Full[Complete Control]
            PSU --> Major[Major Control]
            PSU --> Strategic[Strategic Sectors]
            
            Full --> Transport[Railways & Highways]
            Major --> Banking[Banking & Insurance]
            Strategic --> Defense[Defense & Space]
            Strategic --> Digital[Digital & Telecom]
            Strategic --> Energy[Energy & Utilities]
        """

--------------------------------------------------------------------------------

# File: layout/__init__.py


--------------------------------------------------------------------------------

# File: layout/layout.py
# layout/layout.py

from dataclasses import dataclass, field
from typing import Dict, List, Tuple, Literal
from collections import defaultdict
import logging
import json

logger = logging.getLogger(__name__)

@dataclass
class LayoutNode:
    id: str
    label: str
    type: str
    x: float = 0
    y: float = 0
    width: float = 80
    height: float = 80
    rank: int = 0
    order: int = 0
    dummy: bool = False

@dataclass
class LayoutEdge:
    from_id: str
    to_id: str
    label: str = ""
    points: List[Tuple[float, float]] = field(default_factory=list)
    dummy_nodes: List[str] = field(default_factory=list)

@dataclass
class GraphLayout:
    nodes: Dict[str, LayoutNode]
    edges: List[LayoutEdge]
    width: float
    height: float
    direction: str = "TD"  # Added direction field
    ranks: Dict[int, List[str]] = field(default_factory=lambda: defaultdict(list))

class SugiyamaLayoutGenerator:
    """Implements Sugiyama's algorithm for layered graph drawing with direction support"""
    
    def __init__(self, width: float = 1920, height: float = 1080,
                 node_spacing: float = 150, rank_spacing: float = 250):
        self.width = width
        self.height = height
        self.node_spacing = node_spacing
        self.rank_spacing = rank_spacing
        self.dummy_counter = 0
        self.direction = "TD"  # Default direction

    def generate_layout(self, parsed_graph) -> GraphLayout:
        """Main method to generate layout"""
        # Get direction from parsed graph
        self.direction = parsed_graph.direction
        
        # Initialize layout
        nodes = {
            node_id: LayoutNode(
                id=node_id,
                label=node.label,
                type=node.type.value
            )
            for node_id, node in parsed_graph.nodes.items()
        }
        
        edges = [
            LayoutEdge(
                from_id=edge.from_id,
                to_id=edge.to_id,
                label=edge.label
            )
            for edge in parsed_graph.edges
        ]
        
        # Create graph layout
        layout = GraphLayout(nodes, edges, self.width, self.height, self.direction)
        
        # Apply Sugiyama algorithm steps
        self._assign_ranks(layout)
        self._normalize_edges(layout)
        self._optimize_crossings(layout)
        self._assign_coordinates(layout)
        
        return layout

    def _assign_ranks(self, layout: GraphLayout) -> None:
        """Step 1: Assign ranks to nodes using longest path layering"""
        # Find nodes with no incoming edges
        incoming_edges = {e.to_id for e in layout.edges}
        roots = [nid for nid in layout.nodes.keys() if nid not in incoming_edges]
        
        if not roots:
            roots = [next(iter(layout.nodes.keys()))]
            logger.warning(f"No root nodes found, using {roots[0]} as root")
        
        # Initialize ranks
        ranks = defaultdict(list)
        assigned = set()
        
        def assign_rank(node_id: str, rank: int) -> None:
            node = layout.nodes[node_id]
            if node_id in assigned:
                node.rank = max(node.rank, rank)
            else:
                node.rank = rank
                assigned.add(node_id)
            
            ranks[rank].append(node_id)
            
            # Process outgoing edges
            outgoing = [e for e in layout.edges if e.from_id == node_id]
            for edge in outgoing:
                if edge.to_id not in assigned:
                    assign_rank(edge.to_id, rank + 1)
        
        # Assign ranks starting from roots
        for root in roots:
            assign_rank(root, 0)
        
        layout.ranks = ranks

    def _normalize_edges(self, layout: GraphLayout) -> None:
        """Step 2: Add dummy nodes for edges spanning multiple ranks"""
        new_edges = []
        
        for edge in layout.edges:
            source = layout.nodes[edge.from_id]
            target = layout.nodes[edge.to_id]
            
            if target.rank - source.rank > 1:
                # Create dummy nodes for long edges
                current_id = edge.from_id
                dummy_nodes = []
                
                for rank in range(source.rank + 1, target.rank):
                    dummy_id = f"dummy_{self.dummy_counter}"
                    self.dummy_counter += 1
                    
                    # Create dummy node
                    layout.nodes[dummy_id] = LayoutNode(
                        id=dummy_id,
                        label="",
                        type="default",
                        rank=rank,
                        dummy=True,
                        width=10,
                        height=10
                    )
                    layout.ranks[rank].append(dummy_id)
                    dummy_nodes.append(dummy_id)
                    
                    # Create edge to dummy node
                    new_edges.append(LayoutEdge(
                        from_id=current_id,
                        to_id=dummy_id
                    ))
                    current_id = dummy_id
                
                # Connect last dummy to target
                new_edges.append(LayoutEdge(
                    from_id=current_id,
                    to_id=edge.to_id
                ))
                
                # Store dummy nodes in original edge
                edge.dummy_nodes = dummy_nodes
            else:
                new_edges.append(edge)
        
        layout.edges = new_edges

    def _optimize_crossings(self, layout: GraphLayout) -> None:
        """Step 3: Minimize edge crossings between adjacent ranks"""
        MAX_ITERATIONS = 24
        
        def count_crossings(rank1: List[str], rank2: List[str]) -> int:
            """Count number of edge crossings between two ranks"""
            crossings = 0
            edges1 = []
            
            for idx1, n1 in enumerate(rank1):
                for e in layout.edges:
                    if e.from_id == n1 and e.to_id in rank2:
                        pos2 = rank2.index(e.to_id)
                        edges1.append((idx1, pos2))
            
            for i, (a1, a2) in enumerate(edges1):
                for b1, b2 in edges1[i+1:]:
                    if (a1 - b1) * (a2 - b2) < 0:
                        crossings += 1
            
            return crossings

        def optimize_rank_order(rank_idx: int) -> None:
            """Optimize ordering of nodes in one rank"""
            if rank_idx not in layout.ranks:
                return
                
            current_rank = layout.ranks[rank_idx]
            best_order = current_rank.copy()
            best_crossings = float('inf')
            
            # Try different permutations
            for i in range(len(current_rank)):
                for j in range(i + 1, len(current_rank)):
                    current_rank[i], current_rank[j] = current_rank[j], current_rank[i]
                    
                    crossings = 0
                    if rank_idx > 0:
                        crossings += count_crossings(
                            layout.ranks[rank_idx - 1], current_rank)
                    if rank_idx + 1 in layout.ranks:
                        crossings += count_crossings(
                            current_rank, layout.ranks[rank_idx + 1])
                    
                    if crossings < best_crossings:
                        best_crossings = crossings
                        best_order = current_rank.copy()
                    else:
                        current_rank[i], current_rank[j] = current_rank[j], current_rank[i]
            
            layout.ranks[rank_idx] = best_order
        
        # Iterate multiple times to improve layout
        for _ in range(MAX_ITERATIONS):
            for rank_idx in layout.ranks.keys():
                optimize_rank_order(rank_idx)

    def _assign_coordinates(self, layout: GraphLayout) -> None:
        """Step 4: Assign final x,y coordinates based on graph direction"""
        max_rank = max(layout.ranks.keys())
        
        # Calculate usable area (with margins)
        MARGIN = 100
        usable_width = self.width - (2 * MARGIN)
        usable_height = self.height - (2 * MARGIN)
        
        # Calculate spacing based on direction
        if layout.direction in ["TD", "BT"]:  # Top-down or Bottom-up
            rank_spacing = usable_height / (max_rank + 1)
            max_nodes_in_rank = max(len(nodes) for nodes in layout.ranks.values())
            node_spacing = min(self.node_spacing, usable_width / (max_nodes_in_rank + 1))
            
            for rank, nodes in layout.ranks.items():
                # For TD: y increases with rank
                y = MARGIN + (rank + 1) * rank_spacing if layout.direction == "TD" else \
                    self.height - (MARGIN + (rank + 1) * rank_spacing)
                
                # Center nodes horizontally
                total_width = (len(nodes) - 1) * node_spacing
                start_x = MARGIN + (usable_width - total_width) / 2
                
                for i, node_id in enumerate(nodes):
                    node = layout.nodes[node_id]
                    node.x = start_x + i * node_spacing
                    node.y = y
                    node.order = i
                    
        else:  # LR or RL (Left-to-right or Right-to-left)
            rank_spacing = usable_width / (max_rank + 1)
            max_nodes_in_rank = max(len(nodes) for nodes in layout.ranks.values())
            node_spacing = min(self.node_spacing, usable_height / (max_nodes_in_rank + 1))
            
            for rank, nodes in layout.ranks.items():
                # For LR: x increases with rank
                x = MARGIN + (rank + 1) * rank_spacing if layout.direction == "LR" else \
                    self.width - (MARGIN + (rank + 1) * rank_spacing)
                
                # Center nodes vertically
                total_height = (len(nodes) - 1) * node_spacing
                start_y = MARGIN + (usable_height - total_height) / 2
                
                for i, node_id in enumerate(nodes):
                    node = layout.nodes[node_id]
                    node.x = x
                    node.y = start_y + i * node_spacing
                    node.order = i
        
        # Adjust node positions to ensure they're within bounds
        self._adjust_node_positions(layout)
        # Route edges based on new coordinates
        self._route_edges(layout)

    def _adjust_node_positions(self, layout: GraphLayout) -> None:
        """Adjust node positions to ensure they stay within canvas bounds"""
        MARGIN = 100
        
        for node in layout.nodes.values():
            # Ensure x coordinate is within bounds
            node.x = max(MARGIN + node.width/2, 
                        min(self.width - MARGIN - node.width/2, node.x))
            # Ensure y coordinate is within bounds
            node.y = max(MARGIN + node.height/2, 
                        min(self.height - MARGIN - node.height/2, node.y))

    def _route_edges(self, layout: GraphLayout) -> None:
        """Route edges with proper curvature based on graph direction"""
        for edge in layout.edges:
            source = layout.nodes[edge.from_id]
            target = layout.nodes[edge.to_id]
            
            # Start with direct points
            points = [(source.x, source.y)]
            
            # If edge spans multiple ranks, add intermediate points
            if source.rank < target.rank - 1:
                steps = target.rank - source.rank
                for i in range(1, steps):
                    progress = i / steps
                    if layout.direction in ["TD", "BT"]:
                        x = source.x + (target.x - source.x) * progress
                        y = source.y + (target.y - source.y) * progress
                    else:  # LR, RL
                        x = source.x + (target.x - source.x) * progress
                        y = source.y + (target.y - source.y) * progress
                    points.append((x, y))
            
            points.append((target.x, target.y))
            edge.points = points

    def save_json(self, layout: GraphLayout, filename: str) -> None:
        """Save layout to JSON file"""
        data = {
            'nodes': {
                node_id: {
                    'id': node.id,
                    'label': node.label,
                    'type': node.type,
                    'x': node.x,
                    'y': node.y,
                    'width': node.width,
                    'height': node.height,
                    'rank': node.rank,
                    'order': node.order,
                    'dummy': node.dummy
                }
                for node_id, node in layout.nodes.items()
            },
            'edges': [
                {
                    'from_id': edge.from_id,
                    'to_id': edge.to_id,
                    'label': edge.label,
                    'points': edge.points
                }
                for edge in layout.edges
            ],
            'width': layout.width,
            'height': layout.height,
            'direction': layout.direction
        }
        
        with open(filename, 'w') as f:
            json.dump(data, f, indent=2)

--------------------------------------------------------------------------------

# File: parser/__init__.py


--------------------------------------------------------------------------------

# File: parser/parser.py
# parser/parser.py

from dataclasses import dataclass, field
from typing import Dict, List, Optional
from enum import Enum
import re
import json

class NodeType(Enum):
    DEFAULT = "default"
    SQUARE = "square"      # []
    ROUND = "round"       # ()
    CIRCLE = "circle"     # (())
    DIAMOND = "diamond"   # {}
    HEXAGON = "hexagon"   # {{}}
    STADIUM = "stadium"   # ([])

@dataclass
class ParsedNode:
    id: str
    label: str
    type: NodeType
    next_nodes: List[str] = field(default_factory=list)
    prev_nodes: List[str] = field(default_factory=list)

@dataclass
class ParsedEdge:
    from_id: str
    to_id: str
    label: str = ""
    style: str = "solid"  # solid, dotted, thick

@dataclass
class ParsedGraph:
    direction: str  # TD, LR, etc
    nodes: Dict[str, ParsedNode]
    edges: List[ParsedEdge]

class MermaidParser:
    """Parses Mermaid flowchart syntax into structured data"""
    
    def __init__(self):
        self.direction = "TD"  # Default direction
        self.nodes: Dict[str, ParsedNode] = {}
        self.edges: List[ParsedEdge] = []
        
    def parse(self, mermaid_code: str) -> ParsedGraph:
        """Parse Mermaid code into structured graph data"""
        lines = mermaid_code.strip().split('\n')
        self._parse_direction(lines)
        self._parse_nodes_and_edges(lines)
        return ParsedGraph(self.direction, self.nodes, self.edges)
    
    def _parse_direction(self, lines: List[str]) -> None:
        """Parse graph direction from Mermaid syntax"""
        for line in lines:
            if line.strip().startswith('graph'):
                parts = line.strip().split()
                if len(parts) > 1:
                    direction = parts[1].upper()
                    # Validate and normalize direction
                    if direction in ["TB", "TD"]:  # Top to Bottom
                        self.direction = "TD"
                    elif direction == "BT":  # Bottom to Top
                        self.direction = "BT"
                    elif direction == "LR":  # Left to Right
                        self.direction = "LR"
                    elif direction == "RL":  # Right to Left
                        self.direction = "RL"
                    else:
                        self.direction = "TD"  # Default to Top-Down
                break
    
    def _parse_node_type(self, node_text: str) -> tuple[str, str, NodeType]:
        """Parse node text to determine its type and extract id/label"""
        node_text = node_text.strip()
        node_id = node_text
        label = node_text
        node_type = NodeType.DEFAULT

        if '[' in node_text and ']' in node_text:
            if node_text.startswith('[['):
                node_type = NodeType.SQUARE
                parts = node_text.split('[[')
                node_id = parts[0].strip()
                label = parts[1].strip('[]')
            else:
                node_type = NodeType.SQUARE
                parts = node_text.split('[')
                node_id = parts[0].strip()
                label = parts[1].strip('[]')
        elif '(' in node_text and ')' in node_text:
            if node_text.startswith('(('):
                node_type = NodeType.CIRCLE
                parts = node_text.split('((')
                node_id = parts[0].strip()
                label = parts[1].strip('())')
            else:
                node_type = NodeType.ROUND
                parts = node_text.split('(')
                node_id = parts[0].strip()
                label = parts[1].strip(')')
        elif '{' in node_text and '}' in node_text:
            if node_text.startswith('{{'):
                node_type = NodeType.HEXAGON
                parts = node_text.split('{{')
                node_id = parts[0].strip()
                label = parts[1].strip('}}')
            else:
                node_type = NodeType.DIAMOND
                parts = node_text.split('{')
                node_id = parts[0].strip()
                label = parts[1].strip('}')
                
        node_id = node_id.strip().strip('"').strip("'")
        label = label.strip().strip('"').strip("'")
        return node_id, label, node_type
    
    def _parse_nodes_and_edges(self, lines: List[str]) -> None:
        """Parse nodes and edges from Mermaid code lines"""
        for line in lines:
            if not line.strip() or line.strip().startswith('graph'):
                continue
                
            if '-->' in line:
                parts = line.strip().split('-->')
                
                # Parse source node
                from_id, from_label, from_type = self._parse_node_type(parts[0])
                if from_id not in self.nodes:
                    self.nodes[from_id] = ParsedNode(from_id, from_label, from_type)
                
                # Parse edge and target node
                edge_parts = parts[1].split('|')
                edge_label = ''
                if len(edge_parts) > 1:
                    edge_label = edge_parts[0].strip().strip('"').strip("'")
                    to_id, to_label, to_type = self._parse_node_type(edge_parts[-1])
                else:
                    to_id, to_label, to_type = self._parse_node_type(parts[1])
                
                if to_id not in self.nodes:
                    self.nodes[to_id] = ParsedNode(to_id, to_label, to_type)
                
                # Update node connections
                self.nodes[from_id].next_nodes.append(to_id)
                self.nodes[to_id].prev_nodes.append(from_id)
                
                # Create edge
                self.edges.append(ParsedEdge(from_id, to_id, edge_label))
    
    def save_json(self, filename: str) -> None:
        """Save parsed graph to JSON file"""
        def convert_enum(obj):
            if isinstance(obj, NodeType):
                return obj.value
            return obj.__dict__
            
        graph = ParsedGraph(self.direction, self.nodes, self.edges)
        with open(filename, 'w') as f:
            json.dump(graph, default=convert_enum, indent=2, fp=f)

--------------------------------------------------------------------------------
